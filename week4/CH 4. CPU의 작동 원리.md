# CH 4. CPU의 작동 원리

## 4-1 ALU와 제어장치

### ALU

![alt text](IMG_5446.jpeg)

**ALU**는 레지스터를 통해 **피연산자**를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 **제어 신호**를 받아들인다.

연산을 수행한 결과는 특정 숫자나 문자가 될 수도 있고, 메모리 주소가 될 수도 있다. 그리고 이 결괏값은 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장된다.

CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 훨씬 느리다. ALU가 연산할 때마다 결과를 메모리에 저장한다면 프로그램 실행 속도가 느려지기 때문에 결괏값을 메모리가 아닌 레지스터에 우선 저장한다.

ALU는 계산 결과와 더불어 연산 결과에 대해 추가적인 상태 정보를 나타내는 **플래그**를 내보낸다.

대표적인 플래그 종류에는 부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그 등이 있다.

이러한 플래그는 CPU가 프로그램을 실행하는 도중 반드시 기억해야 하는 일종의 참고 정보이다. 그리고 플래그들은 **플래그 레지스터**라는 레지스터에 저장된다.

### 제어장치

**제어장치**는 제어 신호를 내보내고, 명령어를 해석하는 부품이다. 그리고 **제어 신호**는 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호이다.

#### 제어장치가 받아들이는 정보

**첫째, 제어장치는 클럭 신호를 받아들인다.**

**클럭**이란 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위이다. 컴퓨터의 모든 부품들은 클럭 신호에 맞춰 작동하며 한 박자에 맞춰 작동할 수도 있고 여러 클럭에 걸쳐 실행될 수도 있다.

**둘째, 제어장치는 '해석해야 할 명령어'를 받아들인다.**

CPU가 해석해야 할 명령어는 **명령어 레지스터**라는 특별한 레지스터에 저장된다. 제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려준다.

**셋째, 제어장치는 플래그 레지스터 속 플래그 값을 받아들인다.**

제어장치는 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킨다.

**넷째, 제어장치는 시스템 버스, 그중에서 제어 버스로 전달된 제어 신호를 받아들인다.**

제어신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있다. 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기도한다.

#### 제어장치가 내보내는 정보

제어장치가 내보내는 정보에는 크게 CPU 외부에 전달하는 제어 신호와 CPU 내부에 전달하는 제어 신호가 있다.

제어장치가 CPU 외부에 제어 신호를 전달한다는 말은 곧, 제어 버스로 제어 신호를 내보낸다는 말과 간다. 이러한 제어 신호에는 크게 **메모리에 전달하는 제어 신호**와 **입출력장치에 전달하는 제어 신호**가 있다.

제어장치가 CPU 내부에 전달하는 제어 신호에는 크게 **ALU에 전달하는 제어 신호**와 **레지스터에 전달하는 제어 신호**가 있다.

## 4-2 레지스터

### 반드시 알아야 할 레지스터

#### 프로그램 카운터

**프로그램 카운터**(PC)는 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장한다. 프로그램 카운터를 **명령어 포인터**(IP: Instruction Pointer)라고 부르는 CPU도 있다.

#### 명령어 레지스터

**명령어 레지스터**는 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터이다. 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보낸다.

#### 메모리 주소 레지스터

**메모리 주소 레지스터**는 메모리의 주소를 저장하는 레지스터이다. CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다.

#### 메모리 버퍼 레지스터

메모리 버퍼 레지스터는 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터이다. 즉, 메모리에 쓰고 싶은 값이나 메모리부터 전달받은 값은 메모리 버퍼 레지스터를 거친다.

#### 범용 레지스터

범용 레지스터는 이름 그대로 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터이다. 범용 레지스터는 데이터와 주소를 모두 저장할 수 있다. 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있고, 현대 대다수 CPU는 모두 범용 레지스터를 갖고 있다.

#### 플래그 레지스터

**플래그 레지스터**는 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터이다.

### 특정 레지스터를 이용한 주소 지정방식(1): 스택 주소 지정 방식

프로그램 카운터, 스택 포인터, 베이스 레지스터는 주소 지정에 사용될 수 있는 특별한 레지스터이다. **스택 포인터**는 스택 주소 지정 방식이라는 주소 지정 방식에 사용되고, 프로그램 카운터와 레지스터는 변위 주소 지정 방식이라는 주소 지정 방식에 사용된다.

**스택 주소 지정 방식**은 스태과 스택 포인터를 이용한 주소 지정 방식이다. **스택 포인터**는 스택의 꼭대기를 가리키는 레지스터이다. 즉, 스택 포인터는 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터이다. 스택은 메모리 안에 **스택 영역**을 따로 지정하여 사용한다.

### 특정 레지스터를 이용한 주소 지정방식(2): 변위 주소 지정 방식

**변위 주소 지정 방식**이란 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식이다. 그래서 변위 주소 지정 방식을 사용하는 명령어는 연산 코드 필드, 어떤 레지스터의 값과 더할지를 나타내는 레지스터 필드, 그리고 주소를 담고 있는 오퍼랜드 필드가 있다.

이때, 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 **상대 주소 지정 방식, 베이스 레지스터 지정 방식** 등으로 나뉜다.

#### 상대 주소 지정 방식

**상대 주소 지정 방식**은 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식이다.

프로그램 카운터에는 읽어 들일 명령어의 주소가 저장되어 있다. 만약 오퍼랜드가 -3이었다면 CPU는 읽어 들이기로 한 명령어로부터 '세 번째 이전'번지로 접근한다. 한마디로 실행하려는 명령어의 세 칸 이전 번지 명령어를 실행하는 것이다.

#### 베이스 레지스터 주소 지정 방식

**베이스 레지스터 주소 지정 방식**은 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식이다. 여기서 베이스 레지스터는 '기준 주소', 오퍼랜드는 '기준 주소로부터 떨어진 거리'로서의 역할을 한다.

## 4-3 명령어 사이클과 인터럽트

### 명령어 사이클

프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 명령어 사이클이라고 한다. 즉, 프로그램 속 각각의 명령어들은 명령어 사이클이 반복되며 실행된다.

명령어 사이클의 첫 번째 과정은 명령어를 메모리에서 CPU로 가져오는 **인출 사이클**이다. 두번째 과정은 CPU로 가져온 명령어를 실행하는 **실행 사이클**이다. 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계가 실행 사이클이다. 프로그램을 이루는 수많은 명령어는 일반적으로 인출과 실행 사이클을 반복하며 실행된다.

하지만 명령어를 인출하여 CPU로 가져왔다 하더라도 곧바로 실행할 수 없는 경우도 있다. 간접 주소 지정 방식처럼 명령어를 실행하기 위해 메모리 접근을 한 번 더 해야 하는 단계를 **간접 사이클**이라고 한다.

### 인터럽트

CPU가 수행 중인 작업은 방해를 받아 잠시 중단될 수 있는데, 이렇게 CPU의 작업을 방해하는 신호를 **인터럽트**라고 한다. 인터럽트의 종류에는 크게 동기 인터럽트와 비동기 인터럽트가 있다.

**동기 인터럽트**는 CPU에 의해 발생하는 인터럽트이다. CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때 발생하는 인터럽트가 동기 인터럽트이다. 이런 점에서 동기 인터럽트는 예외라고도 부른다. 예외의 종류에는 폴트, 트랩, 중단, 소프트웨어 인터럽트가 있다.

**비동기 인터럽트**는 주로 입출력장치에 의해 발생하는 인터럽트이다. 입출력장치에 의한 비동기 인터럽트는 알림 역할을 한다.

- CPU가 프린터와 같은 입출력장치에 입출력 작업을 부탁하면 작업을 끝낸 입출력장치가 CPU에 완료 알림(인터럽트)을 보낸다.
- 키보드, 마우스와 같은 입출력장치가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU에 입력 알림(인터럽트)을 보낸다.

일반적으로 비동기 인터럽트를 인터럽트라 칭하기도 한다. 다른 이름은 **하드웨어 인터럽트**이다.

#### 하드웨어 인터럽트

**하드웨어 인터럽트**는 알림과 같은 인터럽트이다. CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 이런 알림과 같은 하드웨어 인터럽트를 사용한다.

#### 하드웨어 인터럽트 처리순서

1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 **인터럽트 백터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개한다.

인터럽트는 CPU의 정상적인 실행 흐름을 끊는 것이기에 인터럽트 전에 인터럽트가 가능한지 확인하는 **인터럽트 요청 신호**를 보내야 한다. 이때, CPU가 인터럽트 요청을 수용하기 위해서는 플래그 레지스터의 **인터럽트 플래그**가 활성화되어 있어야 한다. 인터럽트 플래그는 말 그대로 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그이다. 다만, 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아니다. 정전이나 하드웨어 고장으로 인한 인터럽트는 막을 수 없는 인터럽트에 해당한다.

CPU가 인터럽트 요청을 받아들이기로 했다면 CPU는 인터럽트 서비스 루틴이라는 프로그램을 실행한다. **인터럽트 서비스 루틴**은 인터럽트를 처리하기 위한 프로그램이다. **인터럽트 핸들러**라고도 부른다. 요컨대 'CPU가 인터럽트를 처리한다'는 말은 '인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업을 다시 되돌아온다'라는 말과 같다. 인터럽트를 처리하는 방법은 입출력장치마다 다르므로 각기 다른 인터럽트 서비스 루틴을 가지고 있다. 즉, 메모리에는 여러 개의 인터럽트 서비스 루틴이 저장되어 있다. 이들 하나하나가 '인터럽트가 발생하면 어떻게 행동해야 할지를 알려주는 프로그램'이라고 보면 된다.

CPU는 수많은 인터럽트 서비스 루틴을 구분하기 위해 인터럽트 벡터를 이용한다. **인터럽트 벡터**는 인터럽트 서비스 루틴을 식별하기 위한 정보이다. 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있기 때문에 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있다.
