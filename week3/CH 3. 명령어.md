# CH 3. 명령어

## 3-1 소스코드와 명령어

### 고급 언어와 저급 언어

#### 고급 언어

컴퓨터는 이해하지 못하는 사람이 이해하고 작성하기 쉽게 만들어진 언어

#### 저급 언어

컴퓨터가 직접 이해하고 실행할 수 있는 언어. 저급 언어는 명령어로 이루어져 있다. 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어, 즉 명령어로 변환되어야 한다. 저급 언어에는 **기계어**와 **어셈블리어**가 있다.

##### 기계어

0과 1의 명령어 비트로 이루어진 언어. 2진수로 나열하면 너무 길어져 가독성을 위해 16진수로 표현하기도 한다. 기계어는 오로지 컴퓨터만을 위해 만들어진 언어이기 때문에 사람이 읽으면 그 의미를 이해하기 어렵다.

##### 어셈블리어

기계어를 읽기 편한 형태로 번역한 언어. 보통은 아니지만 하드웨어와 밀접하게 맞닿아 있는 프로그램을 개발하는 임베디드, 게임, 정보 보안 분야등의 개발자는 어셈블리어를 많이 이용한다. 어셈블리어를 읽으면 컴퓨터가 프로그램을 어떤 과정으로 실행하는지, 즉 프로그램이 어떤 절차로 작동하는지를 가장 근본적인 단계에서부터 하나하나 추적하고 관찰할 수 있다.

### 컴파일 언어와 인터프리터 언어

고급 언어에서 저급 언어로 변환되는 방식에는 **컴파일** 방식과 **인터프리트** 방식이 있다. 컴파일 방식으로 작동하는 프로그래밍 언어를 **컴파일 언어**, 인터프리트 방식으로 작동하는 프로그래밍 언어를 **인터프리터 언어**라고 한다.

#### 컴파일 언어

**컴파일 언어**는 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어이다. 컴파일러가 소스 코드 내에서 오류를 하나라도 발견하면 해당 소스 코드는 컴파일에 실패한다.

컴파일이 성공적으로 수행되면 개발자가 작성한 소스 코드는 컴퓨터가 이해할 수 있는 저급언어로 변환된다. 이렇게 컴파일러를 통해 저급 언어로 변환된 코드를 **목적 코드**라고 한다.

#### 인터프리터 언어

**인터프리터 언어**는 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어이다. 컴파일 언어와는 달리, 인터프리터 언어는 소스 코드를 한 줄씩 차례로 실행하기 때문에 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없고 소스 코드 N번째 줄에 문법 오류가 있더라도 N-1번째 줄까지는 올바르게 수행된다.

일반적으로 인터프리터 언어는 컴파일 언어보다 느리다. 컴파일을 통해 나온 목적 코드는 컴퓨터가 이해하고 실행할 수 있는 저급 언어인 반면, 인터프리터 언어는 소스 코드 마지막에 이를 때까지 한 줄씩 저급 언어로 해석하며 실행해야 하기 때문이다.

> 하나의 프로그래밍 언어가 반드시 둘 중 하나의 방식으로만 작동하는 것은 아니다!

### 목적 파일 vs 실행 파일

목적코드로 이루어진 파일을 **목적 파일**이라고 부른다. 마찬가지로 실행 코드로 이루어진 파일을 **실행 파일**이라고 부른다. 윈도우의 .exe 파일이 대표적인 실행파일이다. 목적 코드가 실행 파일이 되기 위해서는 **링킹**이라는 작업을 거쳐야 한다.

## 3-2. 명령어의 구조

### 연산 코드와 오퍼랜드

**명령어**는 연산 코드와 오퍼랜드로 구성되어 있다. '명령어가 수행할 연산'을 **연산 코드**라 하고, '연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치'를 **오퍼랜드**라고 한다. 연산 코드는 **연산자**, 오퍼랜드는 **피연산자**라고도 부른다.

연산 코드가 담기는 영역을 **연산 코드 필드**라고 부르고, 오퍼랜드가 담기는 영역을 **오퍼랜드 필드**라고 한다.

#### 오퍼랜드

오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다. 다만 많은 경우에 데이터를 직접 명시하기 보다, 메모리 주소나 레지스터 이름이 담긴다. 그래서 오퍼랜드 필드를 **주소 필드**라고도 한다.

오퍼랜드가 하나도 없는 명령어를 **0-주소 명령어**, 하나인 명령어를 **1-주소 명령어**, 두 개인 명령어를 **2-주소 명령어**, 세 개인 명령어를 **3-주소 명령어**라고 한다.

#### 연산 코드

연산 코드 종류는 매우 많지만, 가장 기본적인 연산 코드 유형은 크게 네 가지이다.

1. 데이터 전송

- **MOVE**: 데이터를 옮겨라
- **STORE**: 메모리에 저장하라
- **LOAD (FETCH)**: 메모리에 CPU로 데이터를 가져와라
- **PUSH**: 스택에 데이터를 저장하라
- **POP**: 스택의 최상단 데이터를 가져와라

2. 산술/논리 연산

- **ADD / SUBTRACT / MULTIPLY / DIVIDE**: 덧셈 / 뺼셈 / 곱셈 / 나눗셈을 수행하라
- **INCREMENT / DECREMENT**: 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
- **AND / OR / NOT**: AND / OR / NOT 연산을 수행하라
- **COMPARE**: 두개의 숫자 또는 TRUE / FALSE 값을 비교하라

3. 제어 흐름 변경

- **JUMP**: 특정 주소로 실행 순서를 옮겨라
- **CONDITIONAL JUMP**: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- **HALT**: 프로그램의 실행을 멈춰라
- **CALL**: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
- **RETURN**: CALL을 호출할 때 저장했던 주소로 돌아가라

4. 입출력 제어

- **READ (INPUT)**: 특정 입출력 장치로부터 데이터를 읽어라
- **WRITE (OUTPUT)**: 특정 입출력 장치로 데이터를 써라
- **START IO**: 입출력 장치를 시작하라
- **TEST IO**: 입출력 장치의 상태를 확인하라

### 주소 지정 방식

오퍼랜드 필드에 데이터를 직접 담지 않고 데이터의 주소를 담는 이유는 데이터를 담기엔 크기가 작기 때문이다. 연산의 대상이 되는 데이터가 저장된 위치를 **유효주소**라고 하며 연산에 사용할 데이터 위치를 찾는 방법을 **주소 지정 방식**이라고 한다.

#### 즉시 주소 지정 방식

**즉시 주소 지정 방식**은 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식이다. 데이터의 크기가 작아지는 단점이 있지만 다른 주소 지정 방식들보다 빠르다.

#### 직접 주소 지정 방식

**직접 주소 지정 방식**은 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식이다. 오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 커졌지만 여전히 유효 주소를 표현할 수 있는 범위는 연산 코드의 비트 수만큼 줄어든다.

#### 간점 주소 지정 방식

**간접 주소 지정 방식**은 유효 주소의 주소를 오퍼랜드 필드에 명시한다. 표현할 수 있는 유효 주소의 범위는 더 넓어졌지만 두 번의 메모리 접근이 필요해 다른 방식들보다 일반적으로 느리다.

#### 레지스터 주소 지정 방식

**레지스터 주소 지정 방식**은 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법이다.

일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다. 그러므로 레지스터 주소 지정 방식은 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다. 하지만 직접 주소 지정 방식과 비슷하게 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.

#### 레지스터 간접 주소 지정 방식

**레지스터 간접 주소 지정 방식**은 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시한다.

유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하지만, 메모리에 접근하는 횟수가 한 번으로 줄어든다. 메모리에 접근하는 것보다 레지스터에 접근하는 것이 더 빠르기 때문에 간접 주소 지정 방식보다 빠르다.
